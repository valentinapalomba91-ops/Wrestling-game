<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gioco da Tavolo Wrestling: The Finish!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="/socket.io/socket.io.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark theme */
        }
        /* Stile specifico per il tabellone */
        #game-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            aspect-ratio: 1 / 1;
            max-width: 600px;
            margin: auto;
            border: 4px solid #ff4136; /* Rosso Wrestling */
            box-shadow: 0 0 20px #ff413680;
            /* FIX CRITICO 1: Aggiunto position: relative per ancorare le pedine */
            position: relative; 
        }

        .cell {
            position: relative;
            height: 100%;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #4a4e69;
            box-sizing: border-box;
            font-size: 0.75rem;
            color: #ffffff;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            background-color: #2e3047;
            transition: background-color 0.3s ease;
        }

        .cell-card {
            background-color: #fca311; /* Giallo per le carte */
            color: #1a1a2e;
        }
        .cell-current {
            background-color: #4cc9f0 !important; /* Blu chiaro per il vincitore */
        }

        /* Posizionamento dei giocatori (pedine) */
        .piece {
            position: absolute;
            font-size: 1.5rem;
            line-height: 1;
            z-index: 10;
            transition: all 0.5s cubic-bezier(.5, 0, .5, 1);
            cursor: pointer;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.9);
            /* FIX CRITICO 2: Centra l'elemento sulla posizione calcolata */
            transform: translate(-50%, -50%); 
        }

        /* Animazione Dado */
        @keyframes dice-roll {
            0%, 100% { transform: translateY(0) rotate(0); }
            50% { transform: translateY(-10px) rotate(360deg); }
        }

        #dice-roller {
            font-family: 'Bangers', cursive;
        }
        
        .dice-rolling {
            animation: dice-roll 0.2s infinite alternate;
        }

        /* Log */
        #game-log {
            height: 200px;
            overflow-y: auto;
            border-radius: 8px;
            background-color: #1f2038;
            padding: 10px;
            font-size: 0.85rem;
        }
        .log-dice { color: #4cc9f0; }
        .log-card { color: #fca311; }
        .log-malus { color: #ff4136; }
        .log-bonus { color: #00b894; }
        .log-win { color: #fcc419; font-weight: bold; }
        .log-effect { color: #8e8e93; }
        .log-error { color: #e74c3c; }
        
        /* Modal */
        .card-modal {
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 50;
        }
        .card-container {
            border: 5px solid;
            background-color: #1a1a2e;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
        }
        
        .card-bonus { border-color: #00b894; } /* Verde */
        .card-malus { border-color: #ff4136; } /* Rosso */
        .card-special { border-color: #4cc9f0; } /* Blu */

    </style>
</head>
<body class="p-4 md:p-8 min-h-screen">

    <!-- Modal per la Carta -->
    <div id="card-modal" class="card-modal fixed inset-0 hidden items-center justify-center p-4 transition-opacity duration-300">
        <div id="card-container" class="card-container rounded-xl p-6 w-full max-w-md text-white text-center">
            <h2 id="card-title" class="text-3xl font-bold font-['Bangers'] mb-4"></h2>
            <p id="card-text" class="text-lg mb-6 font-semibold"></p>
            <div class="p-3 bg-gray-700 rounded-lg shadow-inner">
                <p class="text-sm font-light italic">Effetto:</p>
                <p id="card-effect-desc" class="text-xl font-bold"></p>
            </div>
            <button id="card-close-btn" class="mt-8 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-150">
                OK, Subisci l'Effetto!
            </button>
        </div>
    </div>
    
    <!-- Modal di Vittoria -->
    <div id="win-modal" class="card-modal fixed inset-0 hidden items-center justify-center p-4 transition-opacity duration-300">
        <div class="card-container border-yellow-500 rounded-xl p-8 w-full max-w-lg text-white text-center bg-gray-900">
            <h2 class="text-4xl font-bold font-['Bangers'] mb-4 text-yellow-400">VITTORIA!</h2>
            <p id="win-message" class="text-xl mb-8 font-semibold">Il giocatore X ha vinto la partita!</p>
            <button id="restart-game-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition duration-150">
                Ricomincia Partita
            </button>
        </div>
    </div>

    <!-- Contenitore Principale -->
    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-6 text-white">
            <h1 class="text-5xl font-['Bangers'] text-yellow-400 tracking-wider">WRESTLING: THE FINISH!</h1>
            <p class="text-sm italic text-gray-400">Il Gioco da Tavolo Multi-Player definitivo</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <!-- Colonna 1: Pannello di Controllo -->
            <div class="lg:col-span-1 space-y-4">
                <div class="bg-gray-800 p-4 rounded-xl shadow-lg border-t-4 border-yellow-500">
                    <h2 class="text-xl font-bold text-white mb-3">La Tua Identit√†</h2>
                    <div id="player-info" class="text-white">
                        <p class="text-sm">ID: <span id="my-id" class="font-mono text-gray-400 text-xs"></span></p>
                        <div class="mt-2">
                            <label for="player-name" class="block text-sm font-medium">Nome Giocatore:</label>
                            <input type="text" id="player-name" placeholder="Inserisci il tuo nome" maxlength="15"
                                class="w-full mt-1 p-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-yellow-500 focus:border-yellow-500">
                            <p id="my-symbol-display" class="mt-2 text-2xl font-['Bangers']"></p>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-800 p-4 rounded-xl shadow-lg border-t-4 border-blue-500">
                    <h2 class="text-xl font-bold text-white mb-3">A Chi Tocca</h2>
                    <div id="turn-display" class="flex items-center space-x-3">
                        <div id="current-player-symbol" class="text-4xl">?</div>
                        <p id="current-player-name" class="text-2xl font-bold text-white">Caricamento...</p>
                    </div>
                    <button id="dice-roller" 
                            class="w-full mt-4 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-xl transition duration-150 disabled:bg-gray-500 disabled:cursor-not-allowed">
                        <i class="fas fa-dice mr-2"></i> Tira il Dado!
                    </button>
                    <p id="dice-value-display" class="text-center text-3xl font-['Bangers'] mt-3 text-yellow-400">
                        <span id="last-roll">0</span>
                    </p>
                    <p id="turn-status-message" class="text-center text-sm mt-2 text-gray-300 italic"></p>
                </div>
                
                <div class="bg-gray-800 p-4 rounded-xl shadow-lg border-t-4 border-green-500">
                    <h2 class="text-xl font-bold text-white mb-3">Log di Gioco</h2>
                    <div id="game-log" class="text-gray-200">
                        <!-- Log messages here -->
                    </div>
                </div>
            </div>

            <!-- Colonna 2: Tabellone di Gioco -->
            <div class="lg:col-span-2 flex justify-center items-start pt-6">
                <div id="game-board">
                    <!-- Le caselle verranno generate da JS -->
                </div>
            </div>
            
        </div>
    </div>

    <script>
        const socket = io();
        const TOTAL_CELLS = 100;
        let myId = null;
        let gameState = { players: [], currentPlayerID: null, cardDrawCells: [], game_over: false };
        let cellElements = [];
        let pieceElements = {};

        // --- MAPPATURA UI ---
        const board = document.getElementById('game-board');
        const playerNameInput = document.getElementById('player-name');
        const mySymbolDisplay = document.getElementById('my-symbol-display');
        const myIdDisplay = document.getElementById('my-id');
        const diceRoller = document.getElementById('dice-roller');
        const lastRollDisplay = document.getElementById('last-roll');
        const turnDisplayName = document.getElementById('current-player-name');
        const turnDisplaySymbol = document.getElementById('current-player-symbol');
        const turnStatusMessage = document.getElementById('turn-status-message');
        const gameLog = document.getElementById('game-log');
        const cardModal = document.getElementById('card-modal');
        const cardContainer = document.getElementById('card-container');
        const cardTitle = document.getElementById('card-title');
        const cardText = document.getElementById('card-text');
        const cardEffectDesc = document.getElementById('card-effect-desc');
        const cardCloseBtn = document.getElementById('card-close-btn');
        const winModal = document.getElementById('win-modal');
        const winMessage = document.getElementById('win-message');
        const restartGameBtn = document.getElementById('restart-game-btn');


        // --- FUNZIONI DI UTILIT√Ä ---
        
        // Simula il tiro del dado
        function animateDice(value) {
            return new Promise(resolve => {
                diceRoller.classList.add('dice-rolling');
                lastRollDisplay.textContent = '?';
                setTimeout(() => {
                    diceRoller.classList.remove('dice-rolling');
                    lastRollDisplay.textContent = value;
                    resolve();
                }, 1000);
            });
        }
        
        // Trova il div di una casella dato il numero (1-100)
        function getCellElement(pos) {
            // Mappa l'indice 0-99 alla posizione 1-100
            if (pos >= 1 && pos <= TOTAL_CELLS) {
                return cellElements[pos - 1];
            }
            return null;
        }

        // Calcola l'offset per raggruppare le pedine sulla stessa casella
        function calculateOffset(cellId, pieceId) {
            const playersOnCell = gameState.players.filter(p => p.position === cellId);
            const index = playersOnCell.findIndex(p => p.id === pieceId);
            
            // Usato per distribuire le pedine in un piccolo cerchio o riga
            const angle = (index / playersOnCell.length) * 2 * Math.PI;
            const radius = 10; 

            const offsetX = radius * Math.cos(angle);
            const offsetY = radius * Math.sin(angle);

            return { offsetX, offsetY };
        }

        // Aggiorna la posizione di tutte le pedine in un colpo solo
        function updatePiecesPosition() {
            // Forziamo un ricalcolo delle posizioni del tabellone per assicurare la massima precisione
            const boardRect = board.getBoundingClientRect();
            
            gameState.players.forEach(player => {
                const cell = getCellElement(player.position);
                const piece = pieceElements[player.id];
                
                if (cell && piece) {
                    const cellRect = cell.getBoundingClientRect();
                    
                    const cellCenter = {
                        x: cellRect.left + cellRect.width / 2,
                        y: cellRect.top + cellRect.height / 2
                    };

                    const offset = calculateOffset(player.position, player.id);
                    
                    // Posiziona la pedina rispetto al contenitore del tabellone
                    // Sottraiamo boardRect.left/top per ottenere la coordinata relativa al board
                    piece.style.left = `${cellCenter.x - boardRect.left + offset.offsetX}px`;
                    piece.style.top = `${cellCenter.y - boardRect.top + offset.offsetY}px`;
                }
            });
        }
        
        // Animazione del movimento della pedina
        async function animateMove(player, path) {
            if (!player || !player.id) {
                console.error("[ANIMATION ERROR] Oggetto giocatore nullo o mancante.");
                return;
            }
            
            let piece = pieceElements[player.id];
            if (!piece) {
                console.warn(`[ANIMATION WARNING] Pedina per ID ${player.id} non trovata durante l'animazione. Tentativo di ricreazione.`);
                createPieceElement(player); // Tenta la ricreazione in caso di race condition
                piece = pieceElements[player.id];
                if (!piece) {
                    console.error(`[ANIMATION ERROR] Ricreazione fallita per ID ${player.id}. Animazione saltata.`);
                    return;
                }
            }

            const boardRect = board.getBoundingClientRect();

            // Inizializza l'animazione passo dopo passo
            for (let i = 0; i < path.length; i++) {
                const newPos = path[i];
                const cell = getCellElement(newPos);
                
                if (cell) {
                    const cellRect = cell.getBoundingClientRect();
                    
                    const cellCenter = {
                        x: cellRect.left + cellRect.width / 2,
                        y: cellRect.top + cellRect.height / 2
                    };
                    
                    // Posizionamento intermedio (senza offset per fluidit√†)
                    piece.style.left = `${cellCenter.x - boardRect.left}px`;
                    piece.style.top = `${cellCenter.y - boardRect.top}px`;
                    
                    // Ritardo tra una casella e l'altra
                    await new Promise(r => setTimeout(r, 100)); 
                }
            }
            
            // Applica l'offset finale e la posizione logica dopo l'animazione completa
            // Questo √® gestito dalla chiamata updatePiecesPosition() successiva, ma lo facciamo qui
            // per il singolo pezzo per immediatezza.
            const finalCell = getCellElement(player.position);
            if (finalCell) {
                const cellRect = finalCell.getBoundingClientRect();
                const cellCenter = {
                    x: cellRect.left + cellRect.width / 2,
                    y: cellRect.top + cellRect.height / 2
                };
                const offset = calculateOffset(player.position, player.id);
                piece.style.left = `${cellCenter.x - boardRect.left + offset.offsetX}px`;
                piece.style.top = `${cellCenter.y - boardRect.top + offset.offsetY}px`;
            }

            return true;
        }

        // --- FUNZIONI DI INIZIALIZZAZIONE E RENDER ---

        // Funzione per generare il tabellone 10x10 a spirale
        function createBoard() {
            board.innerHTML = '';
            cellElements = []; // Reset delle reference

            let positions = new Array(TOTAL_CELLS).fill(0).map((_, i) => i + 1);
            let map = []; // Array 10x10

            // Logica a serpente (Snakes & Ladders style)
            for (let r = 0; r < 10; r++) {
                let row = positions.slice(r * 10, (r + 1) * 10);
                // Inverti le righe pari (dall'alto in basso, contando da 0)
                if (r % 2 !== 0) { 
                    row.reverse(); 
                }
                map.push(row);
            }
            // Inverti l'ordine delle righe per far partire la casella 1 in basso a sinistra
            map.reverse(); 
            
            // Aggiungi le caselle al DOM
            map.flat().forEach(pos => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${pos}`;
                cell.textContent = pos;
                
                // Riferimento al div effettivo (per la posizione)
                cellElements.push(cell); 
                
                board.appendChild(cell);
            });

            // Re-order cellElements array to be 1 to 100 for easy access (used for piece positioning later)
            cellElements.sort((a, b) => {
                const posA = parseInt(a.textContent);
                const posB = parseInt(b.textContent);
                return posA - posB;
            });
            
            // Aggiunge le pedine (pieceElements) al tabellone
            // Questo viene chiamato qui e in renderGameState per la massima resilienza
            gameState.players.forEach(player => createPieceElement(player));
        }
        
        // Crea l'elemento DOM per la pedina
        function createPieceElement(player) {
            let piece = pieceElements[player.id];
            if (!piece) {
                piece = document.createElement('div');
                piece.id = `piece-${player.id}`;
                piece.className = 'piece';
                pieceElements[player.id] = piece;
                board.appendChild(piece);
            }
            piece.textContent = player.symbol;
            piece.title = player.name;
            // Assicura che la pedina sia posizionata (utile dopo la creazione)
            const initialCell = getCellElement(player.position || 1);
            if(initialCell) {
                 // Posiziona temporaneamente la pedina al centro della prima cella finch√© updatePiecesPosition non la sposta
                 piece.style.left = '50%';
                 piece.style.top = '50%';
                 updatePiecesPosition();
            }
        }
        
        // Rimuove un elemento pedina (in caso di disconnessione)
        function removePieceElement(playerId) {
            const piece = pieceElements[playerId];
            if (piece) {
                board.removeChild(piece);
                delete pieceElements[playerId];
            }
        }

        // Funzione principale di rendering dello stato
        function renderGameState(newState) {
            gameState = newState;
            
            // 1. Aggiorna la lista dei giocatori / Pedine
            const existingIds = Object.keys(pieceElements);
            const newIds = gameState.players.map(p => p.id);

            // Aggiungi nuove pedine e aggiorna i simboli
            gameState.players.forEach(player => {
                createPieceElement(player); // Garantisce la presenza
            });

            // Rimuovi pedine disconnesse
            existingIds.forEach(id => {
                if (!newIds.includes(id)) {
                    removePieceElement(id);
                }
            });
            
            // 2. Aggiorna la Casella di Turno
            const currentPlayer = gameState.players.find(p => p.id === gameState.currentPlayerID);
            const myPlayer = gameState.players.find(p => p.id === myId);

            if (currentPlayer) {
                turnDisplayName.textContent = currentPlayer.name;
                turnDisplaySymbol.textContent = currentPlayer.symbol;
                diceRoller.disabled = (currentPlayer.id !== myId || gameState.game_over);
                
                if (currentPlayer.id === myId) {
                    turnStatusMessage.textContent = gameState.game_over ? "Partita Terminata." : "√à il tuo turno! Tira il dado.";
                } else {
                    turnStatusMessage.textContent = gameState.game_over ? "Partita Terminata." : `Tocca a ${currentPlayer.name}...`;
                }

                // Indica se il giocatore deve saltare il turno
                if (currentPlayer.skippedTurns > 0) {
                     turnStatusMessage.textContent = `${currentPlayer.name} deve saltare il turno! (${currentPlayer.skippedTurns} rimanenti)`;
                     // Disabilita il dado anche se tocca a me, il server gestir√† il passaggio automatico
                     if (currentPlayer.id === myId && !gameState.game_over) {
                         diceRoller.disabled = true; 
                     }
                }

            } else {
                turnDisplayName.textContent = "In attesa di giocatori...";
                turnDisplaySymbol.textContent = "üé≤";
                diceRoller.disabled = true;
                turnStatusMessage.textContent = "Non abbastanza giocatori o partita terminata.";
            }
            
            // 3. Rimuovi overlay se non sono pi√π necessari
            // Lascia il modal aperto solo se √® il mio turno, la carta √® stata pescata, e il dado √® disabilitato
            if (myPlayer && myPlayer.isDrawingCard) {
                // Lascia che sia il modal handler a gestirne la visibilit√†
            } else {
                cardModal.classList.add('hidden');
                cardModal.classList.remove('flex');
            }
            
            // 4. Aggiorna la UI del tabellone
            updateBoardUI();
            
            // 5. Aggiorna il log
            renderLog();
            
            // 6. Finestra di Vittoria
            if (gameState.game_over) {
                 const winner = gameState.players.find(p => p.position === TOTAL_CELLS);
                 if (winner) {
                    winMessage.textContent = `${winner.name} ${winner.symbol} ha eseguito la sua Finisher ed ha vinto la partita!`;
                 } else {
                    winMessage.textContent = `La partita √® terminata!`;
                 }
                 winModal.classList.add('flex');
                 winModal.classList.remove('hidden');
            } else {
                 winModal.classList.add('hidden');
                 winModal.classList.remove('flex');
            }
        }
        
        // Ridisegna le caselle e riposiziona le pedine
        function updateBoardUI() {
            cellElements.forEach(cell => {
                const pos = parseInt(cell.textContent);
                
                // Reset classi
                cell.classList.remove('cell-card', 'cell-current');
                
                // Caselle Carta
                if (gameState.cardDrawCells.includes(pos)) {
                    cell.classList.add('cell-card');
                }
                
                // Casella Finale
                if (pos === TOTAL_CELLS) {
                    cell.classList.add('cell-current');
                    cell.textContent = "THE FINISH!";
                } else if (pos === 1) {
                    cell.textContent = "START";
                } else {
                    cell.textContent = pos;
                }
            });
            
            // Riposiziona le pedine
            updatePiecesPosition();
        }

        function renderLog() {
            gameLog.innerHTML = '';
            gameState.gameLog.forEach(entry => {
                const logItem = document.createElement('div');
                let colorClass = '';
                
                switch(entry.type) {
                    case 'dice': colorClass = 'log-dice'; break;
                    case 'card': colorClass = 'log-card'; break;
                    case 'malus': colorClass = 'log-malus'; break;
                    case 'bonus': colorClass = 'log-bonus'; break;
                    case 'win': colorClass = 'log-win'; break;
                    case 'effect': colorClass = 'log-effect'; break;
                    case 'error': colorClass = 'log-error'; break;
                    default: colorClass = ''; 
                }
                
                logItem.className = `log-item p-1 border-b border-gray-700 ${colorClass}`;
                logItem.innerHTML = `<span class="text-xs text-gray-500 mr-2">[${entry.timestamp}]</span> ${entry.message}`;
                gameLog.prepend(logItem); // Usa prepend per mostrare i messaggi pi√π recenti in alto
            });
            // Scorrimento automatico in alto per i log (unshift lato server)
            gameLog.scrollTop = 0; 
        }

        // --- GESTIONE DEGLI EVENTI LATO CLIENT ---
        
        // 1. DADO / MOVIMENTO
        diceRoller.addEventListener('click', () => {
            if (diceRoller.disabled) return;
            // Blocca il dado immediatamente dopo la richiesta
            diceRoller.disabled = true;
            socket.emit('roll dice request');
            lastRollDisplay.textContent = '?';
        });

        socket.on('dice roll result', async (result) => {
            renderGameState(result); // Aggiorna lo stato (posizioni logiche)
            
            const moveResult = result.moveResult;
            const player = gameState.players.find(p => p.id === moveResult.playerId);
            
            if (player) {
                await animateDice(moveResult.diceRoll);
                // FIX SICUREZZA: Assicura che l'elemento pedina esista.
                createPieceElement(player); 
                await animateMove(player, moveResult.path);
            }
            
            // Ri-aggiorna la posizione finale e lo stato della UI dopo l'animazione
            // Chiamiamo updatePiecesPosition qui per consolidare la posizione con l'offset corretto
            updatePiecesPosition(); 
            renderLog(); 

            // Comunica al server che il movimento √® finito
            socket.emit('movement finished', moveResult); 
            
            // Logica del turno post-animazione (il server invier√† un nuovo game state update)
            if (moveResult.event && moveResult.event.type === 'card' && player.id === myId) {
                // Se c'√® una carta, mostra il modal per il giocatore che l'ha pescata
                 showCardModal(moveResult.event.data);
            } 
            // Se non c'√® carta, il server gestir√† il passaggio del turno e invier√† un nuovo game state update 
            // che aggiorner√† diceRoller.disabled per il prossimo giocatore.
        });
        
        // 2. CARTA / EFFETTO
        function showCardModal(card) {
            const typeClass = card.type === 'bonus' ? 'card-bonus' : card.type === 'malus' ? 'card-malus' : 'card-special';
            
            cardContainer.className = `card-container rounded-xl p-6 w-full max-w-md text-white text-center ${typeClass}`;
            cardTitle.textContent = card.name;
            cardText.textContent = card.text;
            cardEffectDesc.textContent = card.effect_desc;
            
            cardCloseBtn.textContent = "OK, Subisci l'Effetto!";
            
            // Controlli specifici per carte condizionali (come Eddie)
            const myPlayer = gameState.players.find(p => p.id === myId);
            if (card.name === "I lie, i cheat, I steal!" && myPlayer && myPlayer.position >= 40) {
                 cardEffectDesc.textContent = "Nessun effetto, sei gi√† oltre la casella di arrivo!";
            }

            cardCloseBtn.onclick = () => {
                // Nascondi modal
                cardModal.classList.add('hidden');
                cardModal.classList.remove('flex');
                
                // Richiesta al server di applicare l'effetto
                diceRoller.disabled = true; // Mantieni il dado bloccato durante l'effetto
                socket.emit('card effect request', card);
            };

            cardModal.classList.remove('hidden');
            cardModal.classList.add('flex');
        }

        socket.on('card effect update', async (result) => {
            renderGameState(result); // Aggiorna lo stato (posizioni logiche e log)
            
            const animationPromises = result.playerUpdates.map(update => {
                const player = gameState.players.find(p => p.id === update.id);
                
                if (player) {
                    // FIX SICUREZZA: Assicura che l'elemento pedina esista.
                    createPieceElement(player); 
                    // Il path √® un array di caselle da attraversare. Player.position √® la posizione finale logica.
                    return animateMove(player, update.path);
                }
                return Promise.resolve();
            });
            
            await Promise.all(animationPromises);
            
            // Dopo che tutte le animazioni sono finite
            updatePiecesPosition();
            renderLog();
            
            // 1. Cascata: Se c'√® una carta a cascata, chiedi immediatamente al server l'effetto della nuova carta.
            if (result.cascadedCard && result.cascadedCard.playerID === myId) {
                // Mostra il modal per la carta cascata (e l'utente cliccher√† OK)
                showCardModal(result.cascadedCard.card);
                return;
            }

            // 2. Extra Turn: Se c'√® un turno extra, riabilita il dado per il giocatore corrente.
            if (result.extraTurn && result.cardApplied.playerID === myId) {
                diceRoller.disabled = false;
                turnStatusMessage.textContent = "Hai guadagnato un turno extra! Tira di nuovo.";
            } 
            
            // 3. Fine Logica: Comunica al server che l'animazione della carta √® finita
            socket.emit('card animation finished', result);
            
            // Il server invier√† il nuovo game state update, che abilita il dado se tocca a me.
            // Non c'√® bisogno di riabilitare qui, a meno che non ci sia stato un turno extra.
        });
        
        // 3. EVENTI GENERALI
        socket.on('connect', () => {
            myId = socket.id;
            myIdDisplay.textContent = myId;
            createBoard(); // Inizializza la prima volta
            
            // Carica il nome salvato in localStorage
            const savedName = localStorage.getItem('playerName');
            if (savedName) {
                playerNameInput.value = savedName;
                socket.emit('set player name', savedName);
            }
        });

        socket.on('game state update', (newState) => {
            renderGameState(newState);
            
            // Aggiorna il simbolo locale appena lo stato √® pronto
            const myPlayer = newState.players.find(p => p.id === myId);
            if (myPlayer) {
                mySymbolDisplay.textContent = `Sei ${myPlayer.symbol}`;
            }
        });
        
        // 4. INTERAZIONI UI
        playerNameInput.addEventListener('change', (e) => {
            const newName = e.target.value.trim().substring(0, 15);
            localStorage.setItem('playerName', newName);
            socket.emit('set player name', newName);
        });
        
        restartGameBtn.addEventListener('click', () => {
             socket.emit('start new game request');
        });
        
        window.addEventListener('resize', () => {
            // Ricalcola la posizione delle pedine al ridimensionamento
            updatePiecesPosition();
        });

        // Inizializzazione
        createBoard();
        updatePiecesPosition();

    </script>
</body>
</html>