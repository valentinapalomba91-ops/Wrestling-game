<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wrestling Board Game</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"> 
    
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <!-- Lo stile deve essere fornito separatamente o qui, assumo sia su /style.css -->
    <style>
        :root {
            --cell-size: 8vh;
            --board-gap: 2px;
            --pawn-size: 30px;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f4f4f4;
            color: #333;
            margin: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        header {
            background-color: #343a40;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #my-player-info {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-size: 0.9rem;
        }

        main {
            display: flex;
            flex-grow: 1;
            padding: 20px;
            gap: 20px;
        }

        #status-panel {
            flex-basis: 300px;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
        }
        
        #board-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; 
        }

        #board {
            display: flex;
            flex-wrap: wrap;
            width: calc(10 * var(--cell-size) + 9 * var(--board-gap)); 
            height: calc(10 * var(--cell-size) + 9 * var(--board-gap));
            background-color: #eee;
            border: 5px solid #343a40;
            position: relative;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 1px solid #ccc;
            box-sizing: border-box;
            background-color: #fff;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.8em;
            font-weight: bold;
            transition: background-color 0.1s;
        }

        /* -------------------------------------- */
        /* LAYOUT A SERPENTE (Flexbox Order) */
        /* -------------------------------------- */
        #board {
            flex-direction: row-reverse; /* Inizia da 100 in alto a sinistra */
            flex-wrap: wrap-reverse;     /* Dispone le righe dal basso verso l'alto */
            align-content: flex-start;
        }

        .cell:nth-child(2n) {
            background-color: #f8f8f8;
        }

        .highlight {
            background-color: #ffe0b2 !important; 
            box-shadow: 0 0 10px #ff9800;
        }
        
        .start-cell { background-color: #4CAF50 !important; color: white; }
        .end-cell { background-color: #F44336 !important; color: white; }
        .card-draw { background-color: #2196F3 !important; color: white; }
        .card-icon { font-size: 1.5em; margin-top: 5px; }


        /* -------------------------------------- */
        /* PEDINE */
        /* -------------------------------------- */
        .pawn {
            position: absolute;
            width: var(--pawn-size);
            height: var(--pawn-size);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            font-size: 1.2rem;
            color: black;
            font-weight: bold;
            z-index: 10;
            /* Iniziale: pedina al centro della prima casella (per calcolo) */
            transform: translate(0, 0) translate(-50%, -50%); 
            transition: transform 0.3s ease-in-out; 
            /* Per gli effetti a cascata */
            background-color: white; 
            border: 3px solid #333;
            user-select: none;
        }
        
        .active-pawn {
            border-color: gold !important; 
            box-shadow: 0 0 10px gold;
        }
        
        .pawn-symbol {
            font-size: 1rem;
            line-height: 1;
        }
        
        .pawn-name {
            font-size: 0.5rem;
            text-align: center;
            position: absolute;
            bottom: -15px;
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* -------------------------------------- */
        /* STATUS E LOG */
        /* -------------------------------------- */
        .player-status-list {
            margin-bottom: 15px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .player-entry {
            padding: 3px 0;
        }
        
        .active-player {
            background-color: #e0f7fa;
            border-radius: 3px;
            padding: 3px;
        }

        .log-container {
            flex-grow: 1;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
            overflow-y: auto;
            max-height: 30vh;
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            background-color: #f9f9f9;
        }
        
        .log-title {
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            flex-shrink: 0;
        }

        #message-box {
            display: flex;
            flex-direction: column-reverse; /* Per mostrare gli ultimi messaggi in alto */
            overflow-y: auto;
            flex-grow: 1;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
            border-bottom: 1px dotted #eee;
            font-size: 0.8rem;
        }

        /* Tipi di log per colore */
        .log-dice { color: #007bff; }
        .log-bonus { color: #28a745; }
        .log-malus { color: #dc3545; }
        .log-info { color: #6c757d; }
        .log-penalty { color: #ffc107; }

        /* -------------------------------------- */
        /* MODAL E CONTROLLI */
        /* -------------------------------------- */
        .dice-btn {
            background-color: #ff9800;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        .dice-btn:hover:not(:disabled) {
            background-color: #e68900;
            transform: scale(1.02);
        }

        .dice-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        /* Animazione dado (shake) */
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            20%, 60% { transform: translate(-5px, -5px); }
            40%, 80% { transform: translate(5px, 5px); }
        }

        #dice-result.shake {
            animation: shake 0.3s ease-in-out 3;
            display: inline-block;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        #card-modal .modal-content {
            border: 5px solid gold;
            background: linear-gradient(135deg, #fefefe, #f0f0f0);
        }

        .effect-text {
            margin-top: 10px;
            font-style: italic;
            color: #6c757d;
        }

        .winner-bg {
            background: linear-gradient(45deg, gold, #ffd700, #ffeb3b);
            color: #333;
            border: 10px solid #ccac00;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 5px gold; }
            50% { box-shadow: 0 0 20px gold; }
            100% { box-shadow: 0 0 5px gold; }
        }
        
    </style>
</head>
<body>
    <div id="name-input-modal" class="modal-overlay show">
        <div class="modal-content">
            <h3 class="mb-3">Inserisci il tuo Nickname da Wrestler</h3>
            <input type="text" id="player-nickname" class="form-control mb-3" placeholder="Es: The Rock" required maxlength="15"> 
            <button id="join-game-btn" class="btn btn-primary">Entra nel Ring</button>
        </div>
    </div>
    
    <header>
        <h1>Wrestling Board Game üèÜ</h1>
        <div class="header-controls">
            <div id="my-player-info"></div> 
            <button id="audio-toggle-btn" class="dice-btn">üîä Muta</button>
            <button id="roll-dice-btn" class="dice-btn" disabled>Tira Dado! <i class="fas fa-dice"></i></button>
        </div>
    </header>

    <main>
        <section id="status-panel">
            <h2>Stato Partita</h2>
            <div id="player-status" class="player-status-list">In attesa di giocatori...</div>
            <p>Dado: <span id="dice-result">0</span></p>
            
            <div id="main-status-message" class="alert alert-info mt-2">
                <span id="status-icon" style="margin-right: 5px;"></span>
                <span id="status-text">In attesa di giocatori...</span>
            </div> 

            <div id="log-container" class="log-container">
                <div class="log-title">Cronologia Eventi üìú</div>
                <div id="message-box" class="mt-1">
                    <!-- Messaggi di log qui -->
                </div> 
            </div>
            
            <!-- Bottone Pronto per iniziare il gioco -->
            <button id="ready-btn" class="btn btn-success mt-3">Sono Pronto!</button>
        </section>

        <section id="board-container">
            <div id="board">
            </div>
        </section>
    </main>
    
    <!-- Modale Carta -->
    <div id="card-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="card-name">Carta Speciale!</h2>
            <p id="card-text"></p>
            <div id="card-effect-desc" class="effect-text"></div>
            <button id="resolve-card-btn" class="dice-btn mt-3">OK!</button>
            <input type="hidden" id="card-result-data"> <!-- Per memorizzare l'oggetto cardResult -->
        </div>
    </div>

    <!-- Modale Vittoria -->
    <div id="win-modal" class="modal-overlay">
        <div class="modal-content winner-bg">
            <h2>CONGRATULAZIONI!</h2>
            <p id="winner-message" style="font-size: 1.5em;"></p>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // ==========================================================
        // üéÆ LOGICA CLIENT-SIDE E GESTIONE UI
        // ==========================================================

        const socket = io();
        const TOTAL_CELLS = 100;

        // Elementi UI
        const nameInputModal = document.getElementById('name-input-modal');
        const playerNicknameInput = document.getElementById('player-nickname');
        const joinGameBtn = document.getElementById('join-game-btn');
        const logContainer = document.getElementById('log-container');
        const myPlayerInfo = document.getElementById('my-player-info');
        const mainStatusMessage = document.getElementById('main-status-message');
        const statusIcon = document.getElementById('status-icon');
        const statusText = document.getElementById('status-text');
        const readyBtn = document.getElementById('ready-btn'); // Nuovo bottone Pronto

        const board = document.getElementById('board');
        const rollDiceBtn = document.getElementById('roll-dice-btn');
        const diceResult = document.getElementById('dice-result');
        const playerStatus = document.getElementById('player-status');
        const messageBox = document.getElementById('message-box');
        const cardModal = document.getElementById('card-modal');
        const resolveCardBtn = document.getElementById('resolve-card-btn');
        const cardName = document.getElementById('card-name');
        const cardText = document.getElementById('card-text');
        const cardEffectDesc = document.getElementById('card-effect-desc');
        const cardResultData = document.getElementById('card-result-data'); // Input nascosto per il risultato della carta
        const winModal = document.getElementById('win-modal');
        const winnerMessage = document.getElementById('winner-message');
        const audioToggleBtn = document.getElementById('audio-toggle-btn');


        let boardInitialized = false;
        let lastGameState = null;
        let isWaitingForAnimation = false; 
        let myPlayerName = ''; 
        let myPlayerId = null; // üö® FIX: ID del giocatore locale

        // Variabili audio
        let audioEnabled = true;
        const sounds = {
            diceRoll: new Audio('dado.mp3'),
            cardDraw: new Audio('card.wav'),
            move: new Audio('pedina.wav'),
            win: new Audio('victory.mp3')
        };
        // Aggiungi un listener per gestire il caricamento non riuscito dei file audio
        Object.values(sounds).forEach(s => {
            s.onerror = () => console.warn(`Attenzione: Impossibile caricare il file audio ${s.src}.`);
        });

        // Configurazione volume
        sounds.diceRoll.volume = 0.5;
        sounds.cardDraw.volume = 0.7;
        sounds.move.volume = 0.3;
        sounds.win.volume = 0.8;

        function playSound(soundKey) {
            if (audioEnabled && sounds[soundKey]) {
                const sound = sounds[soundKey];
                sound.currentTime = 0;
                sound.play().catch(e => {
                    // console.error("Audio error: L'utente non ha interagito con la pagina, impossibile riprodurre l'audio.", e);
                });
            }
        }

        audioToggleBtn.addEventListener('click', () => {
            audioEnabled = !audioEnabled;
            audioToggleBtn.innerHTML = audioEnabled ? 'üîä Muta' : 'üîá Audio ON';
            if (!audioEnabled) {
                Object.values(sounds).forEach(s => s.pause());
            }
        });

        // üí• Funzione per l'offset delle pedine
        const PAWN_OFFSETS = [
            { x: 0, y: 0 }, ¬† ¬† ¬† ¬† // Posizione base (centro)
            { x: -8, y: -8 }, ¬† ¬† ¬† // Offset 1: in alto a sinistra
            { x: 8, y: 8 }, ¬† ¬† ¬† ¬† // Offset 2: in basso a destra
            { x: -8, y: 8 }, ¬† ¬† ¬† ¬†// Offset 3: in basso a sinistra
            { x: 8, y: -8 } ¬† ¬† ¬† ¬† // Offset 4: in alto a destra
        ];

        // --------------------------------------------------
        // üß© LOGICA LAYOUT A SERPENTE (INVARIATA)
        // --------------------------------------------------
        
        function getSnakeOrder(cellNumber) {
            const size = 10;
            const row = Math.ceil(cellNumber / size);
            const isEvenRow = row % 2 === 0;
            
            const rowStartValue = TOTAL_CELLS - (row * size) + 1;
            
            if (isEvenRow) {
                return rowStartValue + (cellNumber - (row - 1) * size) - 1;
            } else {
                return rowStartValue + (size - (cellNumber - (row - 1) * size));
            }
        }
        
        /** Costruisce il tabellone di gioco (1-100) */
        function buildBoard(cardDrawCells) {
            if (boardInitialized) return;

            const fragment = document.createDocumentFragment();
            for (let i = 1; i <= TOTAL_CELLS; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${i}`;
                
                const cellNumber = document.createElement('span');
                cellNumber.className = 'cell-number';
                cellNumber.textContent = i;
                cell.appendChild(cellNumber); 

                if (cardDrawCells.includes(i)) {
                    cell.classList.add('card-draw');
                    const cardIcon = document.createElement('i');
                    cardIcon.className = 'fas fa-scroll card-icon'; 
                    cell.appendChild(cardIcon);
                }
                if (i === TOTAL_CELLS) {
                    cell.classList.add('end-cell');
                    cellNumber.textContent = 'FINISH';
                }
                if (i === 1) {
                    cell.classList.add('start-cell');
                    cellNumber.textContent = 'START';
                }
                
                const index = getSnakeOrder(i); 
                cell.style.order = index; 
                fragment.appendChild(cell);
            }
            board.appendChild(fragment);
            boardInitialized = true;
        }

        // --------------------------------------------------
        // üöÄ ANIMAZIONI E MOVIMENTO
        // --------------------------------------------------
        
        /** Muove la pedina nel CSS alla posizione finale della casella, applicando l'offset. */
        function movePawnToCell(pawn, cellNumber, playerIndexOnCell) {
            const cell = document.getElementById(`cell-${cellNumber}`);
            if (!cell) return;

            const cellRect = cell.getBoundingClientRect();
            const boardRect = board.getBoundingClientRect();
            
            let x = cellRect.left - boardRect.left + (cellRect.width / 2);
            let y = cellRect.top - boardRect.top + (cellRect.height / 2);

            // APPLICA OFFSET
            const offsetIndex = (playerIndexOnCell !== undefined) ? (playerIndexOnCell % PAWN_OFFSETS.length) : 0;
            const offset = PAWN_OFFSETS[offsetIndex];

            // Applica l'offset in pixel
            x += offset.x;
            y += offset.y;

            pawn.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%)`;
        }

        /** Esegue l'animazione di movimento su un percorso di caselle */
        function animateMove(playerId, path, finalPosition, allPlayers) {
            const pawn = document.getElementById(`pawn-${playerId}`); 
            
            if (!pawn) {
                console.error("ERRORE CRITICO: Pedina non trovata per l'ID:", playerId, "Animazione saltata.");
                return Promise.resolve(); 
            }

            const durationPerCell = 150; 
            let delay = 0;
            
            pawn.style.transition = `transform ${path.length * durationPerCell / 1000}s linear`; 

            return new Promise(resolve => {
                if (path.length === 0) {
                    // Movimento istantaneo o nullo (serve solo a riposizionare)
                    const playersOnFinalCell = allPlayers.filter(p => p.position === finalPosition);
                    const playerIndexOnFinalCell = playersOnFinalCell.findIndex(p => p.id === playerId);
                    
                    movePawnToCell(pawn, finalPosition, playerIndexOnFinalCell);
                    setTimeout(() => pawn.style.transition = 'none', 10); 
                    resolve();
                    return;
                }

                path.forEach((cellNumber, index) => {
                    delay += durationPerCell;

                    setTimeout(() => {
                        const cell = document.getElementById(`cell-${cellNumber}`);
                        if (cell) {
                            cell.classList.add('highlight');
                            if (index === 0) playSound('move'); 
                        }
                    }, delay - 50); 

                    setTimeout(() => {
                        movePawnToCell(pawn, cellNumber, 0); 
                        
                        if (index > 0) {
                            const prevCell = document.getElementById(`cell-${path[index-1]}`);
                            if (prevCell) {
                                prevCell.classList.remove('highlight');
                            }
                        }
                        
                        if (index === path.length - 1) {
                            setTimeout(() => {
                                // Trova l'indice della pedina sulla casella finale per l'offset corretto
                                const playersOnFinalCell = allPlayers.filter(p => p.position === finalPosition);
                                // ‚úÖ FIX: Corretto il typo da playersOnCell a playersOnFinalCell
                                const playerIndexOnFinalCell = playersOnFinalCell.findIndex(p => p.id === playerId); 
                                
                                pawn.style.transition = 'transform 0.3s ease-out'; 
                                movePawnToCell(pawn, finalPosition, playerIndexOnFinalCell);

                                setTimeout(() => {
                                    pawn.style.transition = 'none'; 
                                    const finalCell = document.getElementById(`cell-${cellNumber}`);
                                    if (finalCell) {
                                        finalCell.classList.remove('highlight');
                                    }
                                    resolve();
                                }, 300); 
                            }, durationPerCell); 
                        }
                    }, delay);
                });
            });
        }

        // --------------------------------------------------
        // üîÑ GESTIONE AGGIORNAMENTI SOCKET.IO
        // --------------------------------------------------

        // üö® FIX: Il server invia l'ID del giocatore quando si connette.
        socket.on('connect', () => {
             // 1. Invia l'ID quando connesso (server lo invia al socket)
             // Non √® necessario un listener specifico, l'ID √® socket.id
             myPlayerId = socket.id; 
             
             // 2. Logica di login
             if (myPlayerName) {
                 nameInputModal.classList.remove('show');
                 socket.emit('set player name', myPlayerName); 
             } else {
                 nameInputModal.classList.add('show');
                 playerNicknameInput.value = ''; 
                 playerNicknameInput.focus();
             }
        });


        /** Listener per l'aggiornamento generale dello stato (NON per l'animazione) */
        socket.on('game state update', (state) => {
            lastGameState = state;
            
            // 1. Inizializzazione tabellone
            if (!boardInitialized) {
                buildBoard(state.cardDrawCells);
            }
            
            // 2. Creazione/Aggiornamento pedine
            updatePawns(state.players);
            
            // 3. AGGIORNAMENTO CRONOLOGIA EVENTI
            updateLog(state.gameLog);
            
            // 4. Aggiorna lo stato dei giocatori e del turno
            updateStatus(state); 
            
            // 5. Gestione visibilit√† bottone Pronto
            readyBtn.style.display = (state.game_started || state.players.find(p => p.id === myPlayerId)?.is_ready) ? 'none' : 'block';
        });

        // ==========================================================
        // üîë FIX: LISTENER PER IL RISULTATO DEL DADO E MOVIMENTO INIZIALE
        // ==========================================================
        socket.on('dice roll result', async (moveResult) => {

            isWaitingForAnimation = true;
            rollDiceBtn.disabled = true;
            
            // Animazione dado
            diceResult.textContent = moveResult.diceRoll;
            diceResult.classList.add('shake');
            playSound('diceRoll');
            
            // Anima il movimento della pedina
            setTimeout(() => {
                diceResult.classList.remove('shake');
                
                // Usiamo moveResult.playerId che ora arriva corretto dal server
                animateMove(
                    moveResult.playerId, 
                    moveResult.path, 
                    moveResult.finalPosition,
                    lastGameState.players 
                ).then(() => {
                    isWaitingForAnimation = false; 
                    
                    // Invia il messaggio al server per avviare la logica della casella (carta/statica)
                    socket.emit('movement finished', moveResult);
                });
            }, 500); 
        });

        // ==========================================================
        // FIX: LISTENER PER LA CARTA PESCATA (MOSTRA MODAL)
        // ==========================================================
        socket.on('card to draw', (eventData) => {
            isWaitingForAnimation = false; 
            
            const card = eventData.card;
            const cardResult = eventData.cardResult;
            
            playSound('cardDraw');
            cardName.textContent = card.name;
            cardText.textContent = card.text; 
            cardEffectDesc.textContent = card.effect_desc;
            
            cardName.style.color = card.type === 'malus' ? '#ff3333' : (card.type === 'bonus' ? '#00ff80' : 'gold');
            
            // Memorizza il risultato completo della carta nell'input nascosto per l'invio
            cardResultData.value = JSON.stringify(eventData);

            cardModal.classList.add('show');
            updateStatus(lastGameState); 
            
            // L'onclick ora usa i dati memorizzati
            resolveCardBtn.onclick = () => {
                cardModal.classList.remove('show');
                
                // Prepara l'oggetto da inviare al server
                const fullCardData = JSON.parse(cardResultData.value);
                
                // Invia l'oggetto completo al server che ora gestisce l'effetto (incluso movimento cascata)
                socket.emit('card effect request', fullCardData); 
                rollDiceBtn.disabled = true; 
                isWaitingForAnimation = true; 
            };
        });

        // ==========================================================
        // FIX: GESTIONE AGGIORNAMENTO DOPO EFFETTO CARTA (CASCATA)
        // ==========================================================
        socket.on('card effect update', async (data) => {
            isWaitingForAnimation = true; 
            
            if (data.playerUpdates && data.playerUpdates.length > 0) {
                
                // Aggiorna lo stato locale con le nuove posizioni (per gli offset finali)
                const playersAfterCard = lastGameState.players.map(p => {
                    const update = data.playerUpdates.find(u => u.id === p.id);
                    if (update) {
                        return { ...p, position: update.newPos }; 
                    }
                    return p;
                });
                lastGameState.players = playersAfterCard; 
                
                // Inizia le animazioni a cascata
                const movePromises = data.playerUpdates.map(update => {
                    return animateMove(update.id, update.path, update.newPos, playersAfterCard);
                });
                
                await Promise.all(movePromises);
                
                // Dopo l'animazione, riposiziona con gli offset corretti
                updatePawns(lastGameState.players);
            }

            // Invia al server che l'animazione √® finita per passare il turno
            socket.emit('card animation finished', data);
            isWaitingForAnimation = false;
        });

        // Gestione fine gioco
        socket.on('game end', (data) => {
            const winner = lastGameState.players.find(p => p.id === data.winner);
            showWin(winner);
        });

        // --------------------------------------------------
        // üî® FUNZIONI DI SUPPORTO UI E LOG 
        // --------------------------------------------------
        
        function updateLog(gameLog) {
            // Aggiorna solo se lo stato del log √® cambiato
            messageBox.innerHTML = ''; 
            
            gameLog.forEach(entry => {
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${entry.type}`; 
                
                let messageHTML = entry.message.replace(/\*\*(.*?)\*\*/g, '<strong>$1');
                
                logEntry.innerHTML = `${messageHTML}`; 
                
                messageBox.prepend(logEntry);
            });
            
            logContainer.scrollTop = 0;
        }

        function updatePawns(players) {
            const positions = {};
            players.forEach(p => {
                positions[p.position] = positions[p.position] || [];
                positions[p.position].push(p);
            });

            let statusListHtml = ''; 

            players.forEach(player => {
                let pawn = document.getElementById(`pawn-${player.id}`); 
                
                if (!pawn) {
                    pawn = document.createElement('div');
                    pawn.id = `pawn-${player.id}`;
                    pawn.className = 'pawn';
                    pawn.innerHTML = `<span class="pawn-symbol" id="symbol-${player.id}">${player.symbol}</span><span class="pawn-name">${player.name}</span>`;
                    board.appendChild(pawn);
                }
                
                pawn.style.zIndex = 10 + player.position; 
                pawn.classList.remove('active-pawn');
                
                const symbolSpan = document.getElementById(`symbol-${player.id}`);
                if (player.skippedTurns > 0) {
                    pawn.classList.add('pawn-skipped');
                    if(symbolSpan) symbolSpan.textContent = 'üö´';
                } else {
                    pawn.classList.remove('pawn-skipped');
                    if(symbolSpan) symbolSpan.textContent = player.symbol;
                }

                if (lastGameState && player.id === lastGameState.currentPlayerID) {
                    pawn.classList.add('active-pawn');
                    pawn.style.zIndex = 100; 
                }
                
                // Calcola l'indice del giocatore sulla casella per l'offset
                const playersOnCell = positions[player.position];
                const playerIndexOnCell = playersOnCell.findIndex(p => p.id === player.id);

                // Posiziona la pedina con l'offset
                movePawnToCell(pawn, player.position, playerIndexOnCell);
                
                // Popola l'HTML per la lista di stato
                statusListHtml += `<div class="player-entry ${player.id === lastGameState.currentPlayerID ? 'active-player' : ''}">
                    <span style="font-weight: bold;">${player.name} ${player.symbol}</span> 
                    - Pos: ${player.position}
                    ${player.skippedTurns > 0 ? ` üö´ Salta ${player.skippedTurns}` : ''}
                </div>`;
            });
            
            playerStatus.innerHTML = statusListHtml; 
        }

        /** Aggiorna il pannello di stato principale e lo stato del pulsante dado. */
        function updateStatus(state) {
            const currentPlayer = state.players.find(p => p.id === state.currentPlayerID);
            const myPlayer = state.players.find(p => p.id === myPlayerId);
            const isWaitingForCardModal = cardModal.classList.contains('show');

            if (myPlayer) {
                myPlayerInfo.innerHTML = `Sei: <span style="font-weight: bold;">${myPlayer.name} ${myPlayer.symbol}</span>`;
            }

            statusIcon.innerHTML = '';
            mainStatusMessage.className = 'alert mt-2';
            rollDiceBtn.disabled = true;

            if (state.game_started === false && state.players.length > 0 && state.players.every(p => p.is_ready)) {
                 // Caso strano: tutti pronti ma non iniziato (dovrebbe essere gestito dal server)
                 mainStatusMessage.classList.add('alert-success');
                 statusText.textContent = "Partita pronta. In attesa di avvio...";
            } else if (state.game_started === false) {
                 mainStatusMessage.classList.add('alert-info');
                 statusText.textContent = `In attesa di almeno 2 giocatori e che tutti premano "Sono Pronto!" (${state.players.filter(p => p.is_ready).length}/${state.players.length})`;
            }
            
            if (state.game_over) {
                mainStatusMessage.classList.add('alert-danger');
                statusText.textContent = "La partita √® finita! üèÜ";
                return;
            }
            
            diceResult.classList.remove('shake');


            if (currentPlayer) {
                const isMyTurn = currentPlayer.id === myPlayerId;
                
                const shouldDisableRoll = !isMyTurn || isWaitingForAnimation || isWaitingForCardModal || currentPlayer.skippedTurns > 0;
                rollDiceBtn.disabled = shouldDisableRoll;

                if (isWaitingForAnimation) {
                    statusText.textContent = "Movimento in corso...";
                    mainStatusMessage.classList.remove('alert-info');
                    mainStatusMessage.classList.add('alert-warning');
                    statusIcon.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                } else if (isWaitingForCardModal) {
                    statusText.textContent = "Carta pescata! Risolvi l'effetto.";
                    mainStatusMessage.classList.remove('alert-info');
                    mainStatusMessage.classList.add('alert-warning');
                    statusIcon.innerHTML = '<i class="fas fa-hand-paper"></i>'; 
                } else if (isMyTurn) {
                    if (myPlayer && myPlayer.skippedTurns > 0) {
                        mainStatusMessage.classList.remove('alert-info');
                        mainStatusMessage.classList.add('alert-danger');
                        statusText.textContent = `Sei bloccato. Salterai ancora ${myPlayer.skippedTurns} turno/i.`;
                        statusIcon.innerHTML = '<i class="fas fa-ban"></i>';
                    } else {
                        mainStatusMessage.classList.remove('alert-info');
                        mainStatusMessage.classList.add('alert-success');
                        statusText.textContent = "√à il tuo turno! Tira il dado. üé≤";
                        statusIcon.innerHTML = '<i class="fas fa-arrow-right"></i>';
                    }
                } else {
                    statusText.textContent = `In attesa del turno di ${currentPlayer.name}...`;
                    mainStatusMessage.classList.add('alert-info');
                    statusIcon.innerHTML = '<i class="fas fa-user-clock"></i>';
                }
            }
        }
        
        function showWin(winner) {
            playSound('win');
            winnerMessage.innerHTML = `${winner.name} ${winner.symbol} ha vinto la **Royal Rumble**!`;
            winModal.classList.add('show');
            rollDiceBtn.disabled = true;
        }

        // --------------------------------------------------
        // üñ±Ô∏è GESTIONE INTERAZIONE UTENTE
        // --------------------------------------------------
        
        joinGameBtn.addEventListener('click', () => {
            const nickname = playerNicknameInput.value.trim();
            if (nickname.length >= 3 && nickname.length <= 15) { 
                myPlayerName = nickname;
                nameInputModal.classList.remove('show');
                socket.emit('set player name', nickname); 
            } else {
                // Sostituito alert() con log o UI temporanea
                console.error("Inserisci un nickname da 3 a 15 caratteri!");
            }
        });

        playerNicknameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                joinGameBtn.click();
            }
        });

        rollDiceBtn.addEventListener('click', () => {
            if (!rollDiceBtn.disabled && !isWaitingForAnimation) {
                rollDiceBtn.disabled = true; 
                isWaitingForAnimation = true; 
                socket.emit('roll dice request');
            }
        });
        
        readyBtn.addEventListener('click', () => {
            readyBtn.disabled = true;
            socket.emit('ready');
        });
        
    </script>
</body>
</html>