<!DOCTYPE html>
<html lang="it">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  Â  <title>Wrestling Board Game</title>
Â  Â  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
Â  Â  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
Â  Â  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"> 
Â  Â  
Â  Â  <link rel="icon" type="image/x-icon" href="/favicon.ico">
Â  Â  
Â  Â  <link rel="stylesheet" href="style.css"> 

</head>
<body>
Â  Â  <div id="name-input-modal" class="modal-overlay show">
Â  Â  Â  Â  <div class="modal-content">
Â  Â  Â  Â  Â  Â  <h3 class="mb-3">Inserisci il tuo Nickname da Wrestler</h3>
Â  Â  Â  Â  Â  Â  <input type="text" id="player-nickname" class="form-control mb-3" placeholder="Es: The Rock" required maxlength="15"> 
Â  Â  Â  Â  Â  Â  <button id="join-game-btn" class="btn btn-primary">Entra nel Ring</button>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â  
Â  Â  <header>
Â  Â  Â  Â  <h1>Wrestling Board Game ğŸ†</h1>
Â  Â  Â  Â  <div class="header-controls">
Â  Â  Â  Â  Â  Â  <div id="my-player-info"></div> 
Â  Â  Â  Â  Â  Â  <button id="audio-toggle-btn" class="dice-btn">ğŸ”Š Muta</button>
Â  Â  Â  Â  Â  Â  <button id="roll-dice-btn" class="dice-btn" disabled>Tira Dado! <i class="fas fa-dice"></i></button>
Â  Â  Â  Â  </div>
Â  Â  </header>

Â  Â  <main>
Â  Â  Â  Â  <section id="status-panel">
Â  Â  Â  Â  Â  Â  <h2>Stato Partita</h2>
Â  Â  Â  Â  Â  Â  <div id="player-status" class="player-status-list">In attesa di giocatori...</div>
Â  Â  Â  Â  Â  Â  <p>Dado: <span id="dice-result">0</span></p>
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  <div id="main-status-message" class="alert alert-info mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  <span id="status-icon" style="margin-right: 5px;"></span>
Â  Â  Â  Â  Â  Â  Â  Â  <span id="status-text">In attesa di giocatori...</span>
Â  Â  Â  Â  Â  Â  </div> 

Â  Â  Â  Â  Â  Â  <div id="log-container" class="log-container">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="log-title">Cronologia Eventi ğŸ“œ</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div id="message-box" class="mt-1">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div> 
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </section>

Â  Â  Â  Â  <section id="board-container">
Â  Â  Â  Â  Â  Â  <div id="board">
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </section>
Â  Â  </main>

Â  Â  <div id="card-modal" class="modal-overlay">
Â  Â  Â  Â  <div class="modal-content">
Â  Â  Â  Â  Â  Â  <h2 id="card-name">Carta Speciale!</h2>
Â  Â  Â  Â  Â  Â  <p id="card-text"></p>
Â  Â  Â  Â  Â  Â  <div id="card-effect-desc" class="effect-text"></div>
Â  Â  Â  Â  Â  Â  <button id="resolve-card-btn" class="dice-btn mt-3">OK!</button>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div id="win-modal" class="modal-overlay">
Â  Â  Â  Â  <div class="modal-content winner-bg">
Â  Â  Â  Â  Â  Â  <h2>CONGRATULAZIONI!</h2>
Â  Â  Â  Â  Â  Â  <p id="winner-message" style="font-size: 1.5em;"></p>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <button class="btn btn-secondary mt-3" onclick="window.location.reload();">Nuova Partita</button>
Â  Â  </div>

Â  Â  <script src="/socket.io/socket.io.js"></script>
Â  Â  <script>
Â  Â  Â  Â  // ==========================================================
Â  Â  Â  Â  // ğŸ® LOGICA CLIENT-SIDE E GESTIONE UI
Â  Â  Â  Â  // ==========================================================

Â  Â  Â  Â  const socket = io();
Â  Â  Â  Â  const TOTAL_CELLS = 100;

Â  Â  Â  Â  // ğŸ’¥ NUOVI ELEMENTI UI
Â  Â  Â  Â  const nameInputModal = document.getElementById('name-input-modal');
Â  Â  Â  Â  const playerNicknameInput = document.getElementById('player-nickname');
Â  Â  Â  Â  const joinGameBtn = document.getElementById('join-game-btn');
Â  Â  Â  Â  const logContainer = document.getElementById('log-container');
Â  Â  Â  Â  const myPlayerInfo = document.getElementById('my-player-info');
Â  Â  Â  Â  const mainStatusMessage = document.getElementById('main-status-message');
Â  Â  Â  Â  const statusIcon = document.getElementById('status-icon');
Â  Â  Â  Â  const statusText = document.getElementById('status-text');

Â  Â  Â  Â  // Elementi UI esistenti
Â  Â  Â  Â  const board = document.getElementById('board');
Â  Â  Â  Â  const rollDiceBtn = document.getElementById('roll-dice-btn');
Â  Â  Â  Â  const diceResult = document.getElementById('dice-result');
Â  Â  Â  Â  const playerStatus = document.getElementById('player-status');
Â  Â  Â  Â  const messageBox = document.getElementById('message-box');
Â  Â  Â  Â  const cardModal = document.getElementById('card-modal');
Â  Â  Â  Â  const resolveCardBtn = document.getElementById('resolve-card-btn');
Â  Â  Â  Â  const cardName = document.getElementById('card-name');
Â  Â  Â  Â  const cardText = document.getElementById('card-text');
Â  Â  Â  Â  const cardEffectDesc = document.getElementById('card-effect-desc');
Â  Â  Â  Â  const winModal = document.getElementById('win-modal');
Â  Â  Â  Â  const winnerMessage = document.getElementById('winner-message');
Â  Â  Â  Â  const audioToggleBtn = document.getElementById('audio-toggle-btn');


Â  Â  Â  Â  let boardInitialized = false;
Â  Â  Â  Â  let lastGameState = null;
Â  Â  Â  Â  let isWaitingForAnimation = false; // ğŸ”‘ CHIAVE: Stato che blocca il gioco
Â  Â  Â  Â  let myPlayerName = ''; 

Â  Â  Â  Â  // Variabili audio
Â  Â  Â  Â  let audioEnabled = true;
Â  Â  Â  Â  const sounds = {
Â  Â  Â  Â  Â  Â  diceRoll: new Audio('/dado.mp3'),
Â  Â  Â  Â  Â  Â  cardDraw: new Audio('/card.wav'),
Â  Â  Â  Â  Â  Â  move: new Audio('/pedina.wav'),
Â  Â  Â  Â  Â  Â  win: new Audio('/victory.mp3')
Â  Â  Â  Â  };
Â  Â  Â  Â  
Â  Â  Â  Â  sounds.diceRoll.volume = 0.5;
Â  Â  Â  Â  sounds.cardDraw.volume = 0.7;
Â  Â  Â  Â  sounds.move.volume = 0.3;
Â  Â  Â  Â  sounds.win.volume = 0.8;

Â  Â  Â  Â  function playSound(soundKey) {
Â  Â  Â  Â  Â  Â  if (audioEnabled) {
Â  Â  Â  Â  Â  Â  Â  Â  const sound = sounds[soundKey];
Â  Â  Â  Â  Â  Â  Â  Â  sound.currentTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  sound.play().catch(e => console.error("Audio error:", e));
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  audioToggleBtn.addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  audioEnabled = !audioEnabled;
Â  Â  Â  Â  Â  Â  // â­ FIX: Aggiornamento del testo per maggiore chiarezza
Â  Â  Â  Â  Â  Â  audioToggleBtn.innerHTML = audioEnabled ? 'ğŸ”Š Muta' : 'ğŸ”‡ Attiva Audio';
Â  Â  Â  Â  Â  Â  if (!audioEnabled) {
Â  Â  Â  Â  Â  Â  Â  Â  Object.values(sounds).forEach(s => s.pause());
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  // ğŸ’¥ Funzione per l'offset delle pedine
Â  Â  Â  Â  const PAWN_OFFSETS = [
Â  Â  Â  Â  Â  Â  { x: 0, y: 0 }, Â  Â  Â  Â  // Posizione base (centro)
Â  Â  Â  Â  Â  Â  { x: -5, y: -5 }, Â  Â  Â  // Offset 1: in alto a sinistra
Â  Â  Â  Â  Â  Â  { x: 5, y: 5 }, Â  Â  Â  Â  // Offset 2: in basso a destra
Â  Â  Â  Â  Â  Â  { x: -5, y: 5 }, Â  Â  Â  Â // Offset 3: in basso a sinistra
Â  Â  Â  Â  Â  Â  { x: 5, y: -5 } Â  Â  Â  Â  // Offset 4: in alto a destra
Â  Â  Â  Â  ];

Â  Â  Â  Â  // --------------------------------------------------
Â  Â  Â  Â  // ğŸ§© LOGICA LAYOUT A SERPENTE
Â  Â  Â  Â  // --------------------------------------------------

Â  Â  Â  Â  // âš ï¸ RIMOSSA FUNZIONE getCellIndex (Duplicata e non usata)
Â  Â  Â  Â  
Â  Â  Â  Â  /** Calcola l'ordine effettivo della cella per il layout a serpente inverso (100 -> 1) su Flexbox. */
Â  Â  Â  Â  function getSnakeOrder(cellNumber) {
Â  Â  Â  Â  Â  Â  const size = 10;
Â  Â  Â  Â  Â  Â  const row = Math.ceil(cellNumber / size);
Â  Â  Â  Â  Â  Â  const isEvenRow = row % 2 === 0;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Ordina dalla fine all'inizio (100 in alto a sinistra, 1 in basso a destra)
Â  Â  Â  Â  Â  Â  const rowStartValue = TOTAL_CELLS - (row * size) + 1;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if (isEvenRow) {
Â  Â  Â  Â  Â  Â  Â  Â  // Le righe pari vanno da destra a sinistra (es. 20, 19, ..., 11)
Â  Â  Â  Â  Â  Â  Â  Â  return rowStartValue + (cellNumber - (row - 1) * size) - 1;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  // Le righe dispari vanno da sinistra a destra (es. 1, 2, ..., 10)
Â  Â  Â  Â  Â  Â  Â  Â  return rowStartValue + (size - (cellNumber - (row - 1) * size));
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  /** Costruisce il tabellone di gioco (1-100) */
Â  Â  Â  Â  function buildBoard(cardDrawCells) {
Â  Â  Â  Â  Â  Â  if (boardInitialized) return;

Â  Â  Â  Â  Â  Â  const fragment = document.createDocumentFragment();
Â  Â  Â  Â  Â  Â  for (let i = 1; i <= TOTAL_CELLS; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const cell = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  cell.className = 'cell';
Â  Â  Â  Â  Â  Â  Â  Â  cell.id = `cell-${i}`;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  const cellNumber = document.createElement('span');
Â  Â  Â  Â  Â  Â  Â  Â  cellNumber.className = 'cell-number';
Â  Â  Â  Â  Â  Â  Â  Â  cellNumber.textContent = i;
Â  Â  Â  Â  Â  Â  Â  Â  cell.appendChild(cellNumber); 

Â  Â  Â  Â  Â  Â  Â  Â  if (cardDrawCells.includes(i)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Aggiunta icona alla casella "carta"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.classList.add('card-draw');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cardIcon = document.createElement('i');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cardIcon.className = 'fas fa-scroll card-icon'; 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.appendChild(cardIcon);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (i === TOTAL_CELLS) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.classList.add('end-cell');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cellNumber.textContent = 'FINISH';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (i === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.classList.add('start-cell');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cellNumber.textContent = 'START';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Uso la funzione per l'ordine a serpente corretto
Â  Â  Â  Â  Â  Â  Â  Â  const index = getSnakeOrder(i); 
Â  Â  Â  Â  Â  Â  Â  Â  cell.style.order = index; 
Â  Â  Â  Â  Â  Â  Â  Â  fragment.appendChild(cell);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  board.appendChild(fragment);
Â  Â  Â  Â  Â  Â  boardInitialized = true;
Â  Â  Â  Â  }

Â  Â  Â  Â  // --------------------------------------------------
Â  Â  Â  Â  // ğŸš€ ANIMAZIONI E MOVIMENTO
Â  Â  Â  Â  // --------------------------------------------------
Â  Â  Â  Â  
Â  Â  Â  Â  /** Muove la pedina nel CSS alla posizione finale della casella, applicando l'offset. */
Â  Â  Â  Â  function movePawnToCell(pawn, cellNumber, playerIndexOnCell) {
Â  Â  Â  Â  Â  Â  const cell = document.getElementById(`cell-${cellNumber}`);
Â  Â  Â  Â  Â  Â  if (!cell) return;

Â  Â  Â  Â  Â  Â  // Utilizza getBoundingClientRect() e board.getBoundingClientRect() per il calcolo
Â  Â  Â  Â  Â  Â  const cellRect = cell.getBoundingClientRect();
Â  Â  Â  Â  Â  Â  const boardRect = board.getBoundingClientRect();
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Calcola la posizione centrale della casella rispetto al tabellone
Â  Â  Â  Â  Â  Â  let x = cellRect.left - boardRect.left + (cellRect.width / 2);
Â  Â  Â  Â  Â  Â  let y = cellRect.top - boardRect.top + (cellRect.height / 2);

Â  Â  Â  Â  Â  Â  // APPLICA OFFSET
Â  Â  Â  Â  Â  Â  const offsetIndex = (playerIndexOnCell !== undefined) ? (playerIndexOnCell % PAWN_OFFSETS.length) : 0;
Â  Â  Â  Â  Â  Â  const offset = PAWN_OFFSETS[offsetIndex];

Â  Â  Â  Â  Â  Â  // Applica l'offset in pixel
Â  Â  Â  Â  Â  Â  x += offset.x;
Â  Â  Â  Â  Â  Â  y += offset.y;

Â  Â  Â  Â  Â  Â  // Sposta la pedina al centro della casella e applica l'offset
Â  Â  Â  Â  Â  Â  pawn.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%)`;
Â  Â  Â  Â  }

Â  Â  Â  Â  /** Esegue l'animazione di movimento su un percorso di caselle */
Â  Â  Â  Â  function animateMove(playerId, path, finalPosition, allPlayers) {
Â  Â  Â  Â  Â  Â  // âœ… CRITICO: Usa il formato ID corretto 'pawn-' + playerId
Â  Â  Â  Â  Â  Â  const pawn = document.getElementById(`pawn-${playerId}`); 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // ğŸ›¡ï¸ SICUREZZA: Controllo per l'errore undefined (dovrebbe essere risolto)
Â  Â  Â  Â  Â  Â  if (!pawn) {
Â  Â  Â  Â  Â  Â  Â  Â  console.error("ERRORE CRITICO: Pedina non trovata per l'ID:", playerId, "Animazione saltata.");
Â  Â  Â  Â  Â  Â  Â  Â  return Promise.resolve(); // Risolvi immediatamente
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const durationPerCell = 150; 
Â  Â  Â  Â  Â  Â  let delay = 0;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  pawn.style.transition = `transform ${path.length * durationPerCell / 1000}s linear`; 

Â  Â  Â  Â  Â  Â  return new Promise(resolve => {
Â  Â  Â  Â  Â  Â  Â  Â  if (path.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Movimento istantaneo o nullo
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const playersOnFinalCell = allPlayers.filter(p => p.position === finalPosition);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const playerIndexOnFinalCell = playersOnFinalCell.findIndex(p => p.id === playerId);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  movePawnToCell(pawn, finalPosition, playerIndexOnFinalCell);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Rimuove la transizione dopo un breve ritardo per le mosse successive
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => pawn.style.transition = 'none', 10); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  resolve();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  path.forEach((cellNumber, index) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  delay += durationPerCell;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 1. Evidenzia la cella e suono
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = document.getElementById(`cell-${cellNumber}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.classList.add('highlight');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Suono solo per l'inizio del movimento (opzionale: su ogni cella)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (index === 0) playSound('move'); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, delay - 50); // Piccola anticipazione per il suono/highlight

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 2. Muovi la pedina
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Per i passi intermedi, usiamo l'offset 0 (centro) per chiarezza
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  movePawnToCell(pawn, cellNumber, 0); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Rimuovi l'evidenziazione dalla cella precedente
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (index > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const prevCell = document.getElementById(`cell-${path[index-1]}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (prevCell) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  prevCell.classList.remove('highlight');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Alla fine dell'animazione
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (index === path.length - 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Muovi alla posizione finale con l'offset corretto
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Trova l'indice della pedina sulla casella finale per l'offset corretto
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const playersOnFinalCell = allPlayers.filter(p => p.position === finalPosition);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const playerIndexOnFinalCell = playersOnFinalCell.findIndex(p => p.id === playerId);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pawn.style.transition = 'transform 0.3s ease-out'; // Transizione per il posizionamento finale
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  movePawnToCell(pawn, finalPosition, playerIndexOnFinalCell);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pawn.style.transition = 'none'; // Rimuovi la transizione dopo il movimento finale
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const finalCell = document.getElementById(`cell-${cellNumber}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (finalCell) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  finalCell.classList.remove('highlight');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  resolve();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 300); // Durata della transizione finale
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, durationPerCell); // Attendi la fine del movimento all'ultima cella
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, delay);
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  // --------------------------------------------------
Â  Â  Â  Â  // ğŸ”„ GESTIONE AGGIORNAMENTI SOCKET.IO
Â  Â  Â  Â  // --------------------------------------------------

Â  Â  Â  Â  /** Listener per l'aggiornamento generale dello stato (NON per l'animazione) */
Â  Â  Â  Â  socket.on('game state update', (state) => {
Â  Â  Â  Â  Â  Â  lastGameState = state;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 1. Inizializzazione tabellone
Â  Â  Â  Â  Â  Â  if (!boardInitialized) {
Â  Â  Â  Â  Â  Â  Â  Â  buildBoard(state.cardDrawCells);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 2. Creazione/Aggiornamento pedine
Â  Â  Â  Â  Â  Â  updatePawns(state.players);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 3. AGGIORNAMENTO CRONOLOGIA EVENTI
Â  Â  Â  Â  Â  Â  updateLog(state.gameLog);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 4. Aggiorna lo stato dei giocatori e del turno
Â  Â  Â  Â  Â  Â  updateStatus(state); 
Â  Â  Â  Â  });

Â  Â  Â  Â  // ==========================================================
Â  Â  Â  Â  // ASCOLTATORE PER IL RISULTATO DEL DADO E MOVIMENTO
Â  Â  Â  Â  // ==========================================================
Â  Â  Â  Â  socket.on('dice roll result', async (moveResult) => {

Â  Â  Â  Â  Â  Â  // 1. Avvia lo stato di animazione e disabilita il dado
Â  Â  Â  Â  Â  Â  isWaitingForAnimation = true;
Â  Â  Â  Â  Â  Â  rollDiceBtn.disabled = true;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 2. Anima il tiro del dado
Â  Â  Â  Â  Â  Â  diceResult.textContent = moveResult.diceRoll;
Â  Â  Â  Â  Â  Â  diceResult.classList.add('shake');
Â  Â  Â  Â  Â  Â  playSound('diceRoll');
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 3. Anima il movimento della pedina
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  diceResult.classList.remove('shake');
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Uso lo stato dei giocatori prima dell'aggiornamento per l'animazione
Â  Â  Â  Â  Â  Â  Â  Â  animateMove(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moveResult.playerId, 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moveResult.path, 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moveResult.finalPosition,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastGameState.players 
Â  Â  Â  Â  Â  Â  Â  Â  ).then(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 4. L'ANIMAZIONE DI MOVIMENTO Ãˆ FINITA:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isWaitingForAnimation = false; 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Invia il messaggio al server per avviare il prossimo passo di gioco.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  socket.emit('movement finished', moveResult); // Passa tutto il moveResult
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }, 500); // Ritardo per l'animazione del dado
Â  Â  Â  Â  });

Â  Â  Â  Â  // ==========================================================
Â  Â  Â  Â  // ASCOLTATORE PER LA CARTA PESCATA (MOSTRA MODAL)
Â  Â  Â  Â  // ==========================================================
Â  Â  Â  Â  socket.on('card to draw', (eventData) => {
Â  Â  Â  Â  Â  Â  isWaitingForAnimation = false; 
Â  Â  Â  Â  Â  Â  showCardModal(eventData.card);
Â  Â  Â  Â  });

Â  Â  Â  Â  // ==========================================================
Â  Â  Â  Â  // GESTIONE AGGIORNAMENTO DOPO EFFETTO CARTA
Â  Â  Â  Â  // ==========================================================
Â  Â  Â  Â  socket.on('card effect update', async (data) => {
Â  Â  Â  Â  Â  Â  isWaitingForAnimation = true; // Blocca tutto per l'animazione degli effetti a cascata
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if (data.playerUpdates && data.playerUpdates.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // 1. Aggiorna le posizioni dei giocatori nello stato locale (per gli offset finali)
Â  Â  Â  Â  Â  Â  Â  Â  const playerUpdatesMap = new Map(data.playerUpdates.map(p => [p.id, p]));
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  const playersAfterCard = lastGameState.players.map(p => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const update = playerUpdatesMap.get(p.id);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (update) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Solo la posizione finale viene aggiornata per l'animazione
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return { ...p, position: update.newPos }; 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return p;
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  lastGameState.players = playersAfterCard; 
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // 2. Inizia le animazioni per tutti i giocatori mossi dall'effetto carta
Â  Â  Â  Â  Â  Â  Â  Â  const movePromises = data.playerUpdates.map(update => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Animiamo da oldPos a newPos
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return animateMove(update.id, update.path, update.newPos, playersAfterCard);
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  await Promise.all(movePromises);
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // 3. Ricalcola gli offset finali per la posizione di arrivo
Â  Â  Â  Â  Â  Â  Â  Â  updatePawns(lastGameState.players);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if (data.win) {
Â  Â  Â  Â  Â  Â  Â  Â  const winner = lastGameState.players.find(p => p.id === data.win); // 'data.win' Ã¨ l'ID
Â  Â  Â  Â  Â  Â  Â  Â  showWin(winner);
Â  Â  Â  Â  Â  Â  Â  Â  isWaitingForAnimation = false;
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if (data.cascadedCard) {
Â  Â  Â  Â  Â  Â  Â  Â  // Se c'Ã¨ una carta a cascata, mostra immediatamente
Â  Â  Â  Â  Â  Â  Â  Â  isWaitingForAnimation = false;
Â  Â  Â  Â  Â  Â  Â  Â  // La cascata non passa il turno, ma riattiva la modal
Â  Â  Â  Â  Â  Â  Â  Â  showCardModal(data.cascadedCard.card);
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 4. L'animazione Ã¨ finita, avvisa il server per far passare il turno
Â  Â  Â  Â  Â  Â  socket.emit('card animation finished', data); // Passa tutti i dati al server per la logica finale
Â  Â  Â  Â  Â  Â  isWaitingForAnimation = false;
Â  Â  Â  Â  });

Â  Â  Â  Â  // --------------------------------------------------
Â  Â  Â  Â  // ğŸ”¨ FUNZIONI DI SUPPORTO UI E LOG 
Â  Â  Â  Â  // --------------------------------------------------
Â  Â  Â  Â  
Â  Â  Â  Â  /** AGGIORNAMENTO COMPLETO DELLA CRONOLOGIA DAL SERVER */
Â  Â  Â  Â  function updateLog(gameLog) {
Â  Â  Â  Â  Â  Â  messageBox.innerHTML = ''; 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  gameLog.forEach(entry => {
Â  Â  Â  Â  Â  Â  Â  Â  const logEntry = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  logEntry.className = `log-entry log-${entry.type}`; 
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Sostituisce il grassetto Markdown (**) con il tag HTML <strong>
Â  Â  Â  Â  Â  Â  Â  Â  let messageHTML = entry.message.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  logEntry.innerHTML = `[${entry.timestamp}] ${messageHTML}`; 
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  messageBox.prepend(logEntry);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  logContainer.scrollTop = 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  function updatePawns(players) {
Â  Â  Â  Â  Â  Â  const positions = {};
Â  Â  Â  Â  Â  Â  players.forEach(p => {
Â  Â  Â  Â  Â  Â  Â  Â  positions[p.position] = positions[p.position] || [];
Â  Â  Â  Â  Â  Â  Â  Â  positions[p.position].push(p);
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  let statusListHtml = ''; 

Â  Â  Â  Â  Â  Â  players.forEach(player => {
Â  Â  Â  Â  Â  Â  Â  Â  // Usa 'pawn-' come ID
Â  Â  Â  Â  Â  Â  Â  Â  let pawn = document.getElementById(`pawn-${player.id}`); 
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  if (!pawn) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pawn = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pawn.id = `pawn-${player.id}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pawn.className = 'pawn';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Aggiunto un tag <span> per il simbolo
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pawn.innerHTML = `<span class="pawn-symbol" id="symbol-${player.id}">${player.symbol}</span><span class="pawn-name">${player.name}</span>`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board.appendChild(pawn);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Il server non manda 'color', quindi usiamo il simbolo come identificatore visivo
Â  Â  Â  Â  Â  Â  Â  Â  pawn.style.zIndex = 10 + player.position; 
Â  Â  Â  Â  Â  Â  Â  Â  pawn.classList.remove('active-pawn');
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Gestione stato 'Skip Turn'
Â  Â  Â  Â  Â  Â  Â  Â  const symbolSpan = document.getElementById(`symbol-${player.id}`);
Â  Â  Â  Â  Â  Â  Â  Â  if (player.skippedTurns > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pawn.classList.add('pawn-skipped');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(symbolSpan) symbolSpan.textContent = 'ğŸš«';
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pawn.classList.remove('pawn-skipped');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(symbolSpan) symbolSpan.textContent = player.symbol;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (lastGameState && player.id === lastGameState.currentPlayerID) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pawn.classList.add('active-pawn');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pawn.style.zIndex = 100; 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Calcola l'indice del giocatore sulla casella per l'offset
Â  Â  Â  Â  Â  Â  Â  Â  const playersOnCell = positions[player.position];
Â  Â  Â  Â  Â  Â  Â  Â  const playerIndexOnCell = playersOnCell.findIndex(p => p.id === player.id);

Â  Â  Â  Â  Â  Â  Â  Â  // Posiziona la pedina con l'offset
Â  Â  Â  Â  Â  Â  Â  Â  movePawnToCell(pawn, player.position, playerIndexOnCell);
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Popola l'HTML per la lista di stato
Â  Â  Â  Â  Â  Â  Â  Â  statusListHtml += `<div class="player-entry ${player.id === lastGameState.currentPlayerID ? 'active-player' : ''}">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span style="font-weight: bold;">${player.name} ${player.symbol}</span> 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  - Pos: ${player.position}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ${player.skippedTurns > 0 ? ` ğŸš« Salta ${player.skippedTurns}` : ''}
Â  Â  Â  Â  Â  Â  Â  Â  </div>`;
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  playerStatus.innerHTML = statusListHtml; 
Â  Â  Â  Â  }

Â  Â  Â  Â  /** Aggiorna il pannello di stato principale e lo stato del pulsante dado. */
Â  Â  Â  Â  function updateStatus(state) {
Â  Â  Â  Â  Â  Â  const currentPlayer = state.players.find(p => p.id === state.currentPlayerID);
Â  Â  Â  Â  Â  Â  const myPlayer = state.players.find(p => p.id === socket.id);
Â  Â  Â  Â  Â  Â  const isWaitingForCard = cardModal.classList.contains('show');

Â  Â  Â  Â  Â  Â  // AGGIORNA LE INFORMAZIONI DEL MIO GIOCATORE
Â  Â  Â  Â  Â  Â  if (myPlayer) {
Â  Â  Â  Â  Â  Â  Â  Â  myPlayerInfo.innerHTML = `Sei: <span style="font-weight: bold;">${myPlayer.name} ${myPlayer.symbol}</span>`;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Inizializza icona e classe
Â  Â  Â  Â  Â  Â  statusIcon.innerHTML = '';
Â  Â  Â  Â  Â  Â  mainStatusMessage.className = 'alert mt-2';
Â  Â  Â  Â  Â  Â  rollDiceBtn.disabled = true;

Â  Â  Â  Â  Â  Â  if (state.game_over) {
Â  Â  Â  Â  Â  Â  Â  Â  mainStatusMessage.classList.add('alert-danger');
Â  Â  Â  Â  Â  Â  Â  Â  statusText.textContent = "La partita Ã¨ finita! ğŸ†";
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Rimuovi la classe 'shake' se presente
Â  Â  Â  Â  Â  Â  diceResult.classList.remove('shake');


Â  Â  Â  Â  Â  Â  if (currentPlayer) {
Â  Â  Â  Â  Â  Â  Â  Â  const isMyTurn = currentPlayer.id === socket.id;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Disabilita il dado se: non Ã¨ il mio turno O Ã¨ in corso un'animazione O sta aspettando una carta O salta il turno
Â  Â  Â  Â  Â  Â  Â  Â  const shouldDisableRoll = !isMyTurn || isWaitingForAnimation || isWaitingForCard || currentPlayer.skippedTurns > 0;
Â  Â  Â  Â  Â  Â  Â  Â  rollDiceBtn.disabled = shouldDisableRoll;

Â  Â  Â  Â  Â  Â  Â  Â  mainStatusMessage.classList.add('alert-info');
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  if (isWaitingForAnimation) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusText.textContent = "Movimento in corso...";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mainStatusMessage.classList.remove('alert-info');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mainStatusMessage.classList.add('alert-warning');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusIcon.innerHTML = '<i class="fas fa-spinner fa-spin"></i>'; // Icona di caricamento
Â  Â  Â  Â  Â  Â  Â  Â  } else if (isWaitingForCard) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusText.textContent = "Carta pescata! Risolvi l'effetto.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mainStatusMessage.classList.remove('alert-info');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mainStatusMessage.classList.add('alert-warning');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusIcon.innerHTML = '<i class="fas fa-hand-paper"></i>'; 
Â  Â  Â  Â  Â  Â  Â  Â  } else if (isMyTurn) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (myPlayer && myPlayer.skippedTurns > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mainStatusMessage.classList.remove('alert-info');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mainStatusMessage.classList.add('alert-danger');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusText.textContent = `Sei bloccato. Salterai ancora ${myPlayer.skippedTurns} turno/i.`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusIcon.innerHTML = '<i class="fas fa-ban"></i>';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mainStatusMessage.classList.remove('alert-info');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mainStatusMessage.classList.add('alert-success');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusText.textContent = "Ãˆ il tuo turno! Tira il dado. ğŸ²";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusIcon.innerHTML = '<i class="fas fa-arrow-right"></i>';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusText.textContent = `In attesa del turno di ${currentPlayer.name}...`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mainStatusMessage.classList.add('alert-info');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusIcon.innerHTML = '<i class="fas fa-user-clock"></i>';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  function showCardModal(card) {
Â  Â  Â  Â  Â  Â  playSound('cardDraw');
Â  Â  Â  Â  Â  Â  cardName.textContent = card.name;
Â  Â  Â  Â  Â  Â  cardText.textContent = card.text; // La proprietÃ  Ã¨ 'text'
Â  Â  Â  Â  Â  Â  cardEffectDesc.textContent = card.effect_desc;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Imposta il colore del titolo in base al tipo di carta
Â  Â  Â  Â  Â  Â  cardName.style.color = card.type === 'malus' ? '#ff3333' : (card.type === 'bonus' ? '#00ff80' : 'gold');
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  cardModal.classList.add('show');
Â  Â  Â  Â  Â  Â  updateStatus(lastGameState); 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  resolveCardBtn.onclick = () => {
Â  Â  Â  Â  Â  Â  Â  Â  cardModal.classList.remove('show');
Â  Â  Â  Â  Â  Â  Â  Â  // Usa l'evento atteso dal server per l'applicazione della carta
Â  Â  Â  Â  Â  Â  Â  Â  socket.emit('card effect request', card); 
Â  Â  Â  Â  Â  Â  Â  Â  rollDiceBtn.disabled = true; 
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  function showWin(winner) {
Â  Â  Â  Â  Â  Â  playSound('win');
Â  Â  Â  Â  Â  Â  // â­ FIX: Usiamo HTML <strong> invece di Markdown **
Â  Â  Â  Â  Â  Â  winnerMessage.innerHTML = `${winner.name} ${winner.symbol} ha vinto la <strong>Royal Rumble</strong>!`;
Â  Â  Â  Â  Â  Â  winModal.classList.add('show');
Â  Â  Â  Â  Â  Â  rollDiceBtn.disabled = true;
Â  Â  Â  Â  }

Â  Â  Â  Â  // --------------------------------------------------
Â  Â  Â  Â  // ğŸ–±ï¸ GESTIONE INTERAZIONE UTENTE E LOGIN
Â  Â  Â  Â  // --------------------------------------------------
Â  Â  Â  Â  
Â  Â  Â  Â  // Gestione del login
Â  Â  Â  Â  joinGameBtn.addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  const nickname = playerNicknameInput.value.trim();
Â  Â  Â  Â  Â  Â  if (nickname.length >= 3 && nickname.length <= 15) { 
Â  Â  Â  Â  Â  Â  Â  Â  myPlayerName = nickname;
Â  Â  Â  Â  Â  Â  Â  Â  nameInputModal.classList.remove('show');
Â  Â  Â  Â  Â  Â  Â  Â  // Usa l'evento atteso dal server
Â  Â  Â  Â  Â  Â  Â  Â  socket.emit('set player name', nickname); 
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  alert("Inserisci un nickname da 3 a 15 caratteri!");
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  // Permetti di inviare il nome anche con Invio
Â  Â  Â  Â  playerNicknameInput.addEventListener('keydown', (e) => {
Â  Â  Â  Â  Â  Â  if (e.key === 'Enter') {
Â  Â  Â  Â  Â  Â  Â  Â  joinGameBtn.click();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  rollDiceBtn.addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  if (!rollDiceBtn.disabled && !isWaitingForAnimation) {
Â  Â  Â  Â  Â  Â  Â  Â  rollDiceBtn.disabled = true; 
Â  Â  Â  Â  Â  Â  Â  Â  isWaitingForAnimation = true; 
Â  Â  Â  Â  Â  Â  Â  Â  socket.emit('roll dice request');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  // Inizializza il tabellone quando lo stato iniziale arriva (dopo il login)
Â  Â  Â  Â  socket.on('connect', () => {
Â  Â  Â  Â  Â  Â  // Se il nome Ã¨ giÃ  stato impostato (riconnessione), invialo di nuovo
Â  Â  Â  Â  Â  Â  if (myPlayerName) {
Â  Â  Â  Â  Â  Â  Â  Â  nameInputModal.classList.remove('show');
Â  Â  Â  Â  Â  Â  Â  Â  socket.emit('set player name', myPlayerName); 
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  nameInputModal.classList.add('show');
Â  Â  Â  Â  Â  Â  Â  Â  playerNicknameInput.value = ''; 
Â  Â  Â  Â  Â  Â  Â  Â  playerNicknameInput.focus();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  </script>
</body>
</html>